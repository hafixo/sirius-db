/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.db.jdbc;

import sirius.kernel.async.ExecutionPoint;
import sirius.kernel.async.Operation;
import sirius.kernel.commons.Watch;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;

/**
 * Used to make connection pooling more robust. (Doesn't call close() twice,
 * etc.).
 */
class WrappedConnection extends DelegatingConnection<Connection> {

    protected final Database database;
    private final Watch watch = Watch.start();
    private final ExecutionPoint connected = ExecutionPoint.fastSnapshot();

    WrappedConnection(Connection c, Database database) {
        super(c);
        this.database = database;
        Databases.numUses.inc();
    }

    @Override
    public String toString() {
        return "WrappedConnection [" + database.getUrl() + "] (" + delegate.toString() + ")";
    }

    @Override
    public void close() throws SQLException {
        try (Operation op = new Operation(() -> database.name + ".close()", Duration.ofSeconds(5))) {
            delegate.close();
        } catch (SQLException e) {
            // Most likely this exception will be a false alert because DBCP 1.2.2 cannot deal with connections which
            // are closed by their driver (due to network issues).
            // The next release of DBCP will fix this problem. The exception is logged at INFO level in case a "real"
            // problem occurred. If we wouldn't call delegate.close, the connection would remain active and might block
            // the pool.
            Databases.LOG.INFO("Error closing connection");
            Databases.LOG.INFO(e);
        } finally {
            watch.submitMicroTiming("SQL", "Connection Duration: " + database.name);
            if (watch.elapsedMillis() > Databases.getLongConnectionThresholdMillis()) {
                Databases.SLOW_DB_LOG.INFO("A long running connection was detected (%s): Opened:\n%s\n\nClosed:\n%s",
                                           watch.duration(),
                                           connected.toString(),
                                           ExecutionPoint.snapshot().toString());
            }
        }
    }

    @Override
    public Statement createStatement() throws SQLException {
        return new WrappedStatement(delegate.createStatement());
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException {
        return new WrappedStatement(delegate.createStatement(resultSetType,
                                                             resultSetConcurrency,
                                                             resultSetHoldability));
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return new WrappedStatement(delegate.createStatement(resultSetType, resultSetConcurrency));
    }

    @Override
    public PreparedStatement prepareStatement(String sql,
                                              int resultSetType,
                                              int resultSetConcurrency,
                                              int resultSetHoldability) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql,
                                                                      resultSetType,
                                                                      resultSetConcurrency,
                                                                      resultSetHoldability), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, resultSetType, resultSetConcurrency), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, autoGeneratedKeys), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, columnIndexes), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, columnNames), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql), sql);
    }
}
