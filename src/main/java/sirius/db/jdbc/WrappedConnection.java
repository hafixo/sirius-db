/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.db.jdbc;

import sirius.kernel.async.Operation;
import sirius.kernel.commons.Watch;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;

/**
 * Used to make connection pooling more robust. (Doesn't call close() twice,
 * etc.).
 */
class WrappedConnection extends DelegatingConnection<Connection> {

    protected final Database ds;
    private final Watch watch = Watch.start();

    WrappedConnection(Connection c, Database ds) {
        super(c);
        this.ds = ds;
        Databases.numUses.inc();
    }

    @Override
    public String toString() {
        return "WrappedConnection [" + ds.getUrl() + "] (" + delegate.toString() + ")";
    }

    @Override
    public void close() throws SQLException {
        try (Operation op = new Operation(() -> ds.name + ".close()", Duration.ofSeconds(5))) {
            delegate.close();
        } catch (SQLException e) {
            // Most likely this exception will be a false alert because DBCP
            // 1.2.2 cannot deal with
            // connections which are closed by their driver (due to network
            // issues).
            // The next release of DBCP will fix this problem. The exception is
            // logged at INFO level
            // in case a "real" problem occurred. If we wouldn't call
            // delegate.close, the connection would
            // remain active and might block the pool.
            Databases.LOG.INFO("Error closing connection");
            Databases.LOG.INFO(e);
        } finally {
            watch.submitMicroTiming("SQL", "Connection Duration: " + ds.name);
        }
    }

    @Override
    public Statement createStatement() throws SQLException {
        return new WrappedStatement(delegate.createStatement());
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException {
        return new WrappedStatement(delegate.createStatement(resultSetType,
                                                             resultSetConcurrency,
                                                             resultSetHoldability));
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return new WrappedStatement(delegate.createStatement(resultSetType, resultSetConcurrency));
    }

    @Override
    public PreparedStatement prepareStatement(String sql,
                                              int resultSetType,
                                              int resultSetConcurrency,
                                              int resultSetHoldability) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql,
                                                                      resultSetType,
                                                                      resultSetConcurrency,
                                                                      resultSetHoldability), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, resultSetType, resultSetConcurrency), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, autoGeneratedKeys), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, columnIndexes), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql, columnNames), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return new WrappedPreparedStatement(delegate.prepareStatement(sql), sql);
    }

}
