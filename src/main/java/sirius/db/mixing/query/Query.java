/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.db.mixing.query;

import sirius.db.mixing.BaseEntity;
import sirius.db.mixing.BaseMapper;
import sirius.db.mixing.EntityDescriptor;
import sirius.db.mixing.Mapping;
import sirius.db.mixing.query.constraints.Constraint;
import sirius.db.mixing.query.constraints.FilterFactory;

/**
 * Describes the minimal functionality to be supported by a query generated by a {@link BaseMapper mapper}.
 *
 * @param <Q> the effective type of the query
 * @param <E> the type of entities being queried
 * @param <C> the type of constraints accepted by this query
 */
public abstract class Query<Q, E extends BaseEntity<?>, C extends Constraint> extends BaseQuery<Q, E> {

    protected Query(EntityDescriptor descriptor) {
        super(descriptor);
    }

    /**
     * Applies the given contraints to the query.
     *
     * @param constraint the constraint which has to be fullfilled
     * @return the query itself for fluent method calls
     */
    public abstract Q where(C constraint);

    public abstract FilterFactory<C> filters();

    /**
     * Adds a constraint which ensures that the given field contains the given value.
     *
     * @param field the name of the field to filter on
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q eq(Mapping field, Object value) {
        return where(filters().eq(field, value));
    }

    /**
     * Adds a constraint which ensures that the given field does not contain the given value.
     *
     * @param field the name of the field to filter on
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q ne(Mapping field, Object value) {
        return where(filters().ne(field, value));
    }

    /**
     * Adds a constraint which ensures that the given field contains the given value.
     * <p>
     * If the given value is <tt>null</tt>, the constraint is skipped.
     *
     * @param field the field to check
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q eqIgnoreNull(Mapping field, Object value) {
        return where(filters().eqIgnoreEmpty(field, value));
    }

    /**
     * Adds a sort constraint to order by the given field ascending.
     *
     * @param field the field to order by.
     * @return the builder itself for fluent method calls
     */
    public abstract Q orderAsc(Mapping field);

    /**
     * Adds a sort constraint to order by the given field descending.
     *
     * @param field the field to order by.
     * @return the builder itself for fluent method calls
     */
    public abstract Q orderDesc(Mapping field);

    /**
     * Executes the query and counts the number of results.
     *
     * @return the number of matched result entries
     */
    public abstract long count();

    /**
     * Determines if the query would have at least one matching entity.
     *
     * @return <tt>true</tt> if at least one entity matches the query, <tt>false</tt> otherwise.
     */
    public abstract boolean exists();

    /**
     * Deletes all matches using the {@link BaseMapper#delete(BaseEntity)} of the appropriate mapper.
     * <p>
     * Be aware that this might be slow for very large result sets.
     */
    public abstract void delete();

    /**
     * Deletes all matches using the capabilities of the underlying database.
     * <p>
     * Therefore <b>no checks</b> or anything will be invoked for the deleted entities.
     * <p>
     * Use this for larger result sets where integrity and constraints do not matter or are managed manually.
     */
    public abstract void truncate();
}
